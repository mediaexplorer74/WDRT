using System;
using System.Runtime.InteropServices;
using System.Security;

namespace System.Reflection.Emit
{
	/// <summary>Provides support for alternative ways to generate the Microsoft intermediate language (MSIL) and metadata for a dynamic method, including methods for creating tokens and for inserting the code, exception handling, and local variable signature blobs.</summary>
	// Token: 0x02000631 RID: 1585
	[ComVisible(true)]
	public class DynamicILInfo
	{
		// Token: 0x06004A22 RID: 18978 RVA: 0x0010D93C File Offset: 0x0010BB3C
		internal DynamicILInfo(DynamicScope scope, DynamicMethod method, byte[] methodSignature)
		{
			this.m_method = method;
			this.m_scope = scope;
			this.m_methodSignature = this.m_scope.GetTokenFor(methodSignature);
			this.m_exceptions = EmptyArray<byte>.Value;
			this.m_code = EmptyArray<byte>.Value;
			this.m_localSignature = EmptyArray<byte>.Value;
		}

		// Token: 0x06004A23 RID: 18979 RVA: 0x0010D990 File Offset: 0x0010BB90
		[SecurityCritical]
		internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm)
		{
			dm.m_methodHandle = ModuleHandle.GetDynamicMethod(dm, module, this.m_method.Name, (byte[])this.m_scope[this.m_methodSignature], new DynamicResolver(this));
		}

		// Token: 0x17000B8A RID: 2954
		// (get) Token: 0x06004A24 RID: 18980 RVA: 0x0010D9C6 File Offset: 0x0010BBC6
		internal byte[] LocalSignature
		{
			get
			{
				if (this.m_localSignature == null)
				{
					this.m_localSignature = SignatureHelper.GetLocalVarSigHelper().InternalGetSignatureArray();
				}
				return this.m_localSignature;
			}
		}

		// Token: 0x17000B8B RID: 2955
		// (get) Token: 0x06004A25 RID: 18981 RVA: 0x0010D9E6 File Offset: 0x0010BBE6
		internal byte[] Exceptions
		{
			get
			{
				return this.m_exceptions;
			}
		}

		// Token: 0x17000B8C RID: 2956
		// (get) Token: 0x06004A26 RID: 18982 RVA: 0x0010D9EE File Offset: 0x0010BBEE
		internal byte[] Code
		{
			get
			{
				return this.m_code;
			}
		}

		// Token: 0x17000B8D RID: 2957
		// (get) Token: 0x06004A27 RID: 18983 RVA: 0x0010D9F6 File Offset: 0x0010BBF6
		internal int MaxStackSize
		{
			get
			{
				return this.m_maxStackSize;
			}
		}

		/// <summary>Gets the dynamic method whose body is generated by the current instance.</summary>
		/// <returns>A <see cref="T:System.Reflection.Emit.DynamicMethod" /> object representing the dynamic method for which the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object is generating code.</returns>
		// Token: 0x17000B8E RID: 2958
		// (get) Token: 0x06004A28 RID: 18984 RVA: 0x0010D9FE File Offset: 0x0010BBFE
		public DynamicMethod DynamicMethod
		{
			get
			{
				return this.m_method;
			}
		}

		// Token: 0x17000B8F RID: 2959
		// (get) Token: 0x06004A29 RID: 18985 RVA: 0x0010DA06 File Offset: 0x0010BC06
		internal DynamicScope DynamicScope
		{
			get
			{
				return this.m_scope;
			}
		}

		/// <summary>Sets the code body of the associated dynamic method.</summary>
		/// <param name="code">An array that contains the MSIL stream.</param>
		/// <param name="maxStackSize">The maximum number of items on the operand stack when the method is executing.</param>
		// Token: 0x06004A2A RID: 18986 RVA: 0x0010DA0E File Offset: 0x0010BC0E
		public void SetCode(byte[] code, int maxStackSize)
		{
			this.m_code = ((code != null) ? ((byte[])code.Clone()) : EmptyArray<byte>.Value);
			this.m_maxStackSize = maxStackSize;
		}

		/// <summary>Sets the code body of the associated dynamic method.</summary>
		/// <param name="code">A pointer to a byte array containing the MSIL stream.</param>
		/// <param name="codeSize">The number of bytes in the MSIL stream.</param>
		/// <param name="maxStackSize">The maximum number of items on the operand stack when the method is executing.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="code" /> is <see langword="null" /> and <paramref name="codeSize" /> is greater than 0.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="codeSize" /> is less than 0.</exception>
		// Token: 0x06004A2B RID: 18987 RVA: 0x0010DA34 File Offset: 0x0010BC34
		[SecurityCritical]
		[CLSCompliant(false)]
		public unsafe void SetCode(byte* code, int codeSize, int maxStackSize)
		{
			if (codeSize < 0)
			{
				throw new ArgumentOutOfRangeException("codeSize", Environment.GetResourceString("ArgumentOutOfRange_GenericPositive"));
			}
			if (codeSize > 0 && code == null)
			{
				throw new ArgumentNullException("code");
			}
			this.m_code = new byte[codeSize];
			for (int i = 0; i < codeSize; i++)
			{
				this.m_code[i] = *code;
				code++;
			}
			this.m_maxStackSize = maxStackSize;
		}

		/// <summary>Sets the exception metadata for the associated dynamic method.</summary>
		/// <param name="exceptions">An array that contains the exception metadata.</param>
		// Token: 0x06004A2C RID: 18988 RVA: 0x0010DA9C File Offset: 0x0010BC9C
		public void SetExceptions(byte[] exceptions)
		{
			this.m_exceptions = ((exceptions != null) ? ((byte[])exceptions.Clone()) : EmptyArray<byte>.Value);
		}

		/// <summary>Sets the exception metadata for the associated dynamic method.</summary>
		/// <param name="exceptions">A pointer to a byte array containing the exception metadata.</param>
		/// <param name="exceptionsSize">The number of bytes of exception metadata.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="exceptions" /> is <see langword="null" /> and <paramref name="exceptionSize" /> is greater than 0.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="exceptionSize" /> is less than 0.</exception>
		// Token: 0x06004A2D RID: 18989 RVA: 0x0010DABC File Offset: 0x0010BCBC
		[SecurityCritical]
		[CLSCompliant(false)]
		public unsafe void SetExceptions(byte* exceptions, int exceptionsSize)
		{
			if (exceptionsSize < 0)
			{
				throw new ArgumentOutOfRangeException("exceptionsSize", Environment.GetResourceString("ArgumentOutOfRange_GenericPositive"));
			}
			if (exceptionsSize > 0 && exceptions == null)
			{
				throw new ArgumentNullException("exceptions");
			}
			this.m_exceptions = new byte[exceptionsSize];
			for (int i = 0; i < exceptionsSize; i++)
			{
				this.m_exceptions[i] = *exceptions;
				exceptions++;
			}
		}

		/// <summary>Sets the local variable signature that describes the layout of local variables for the associated dynamic method.</summary>
		/// <param name="localSignature">An array that contains the layout of local variables for the associated <see cref="T:System.Reflection.Emit.DynamicMethod" />.</param>
		// Token: 0x06004A2E RID: 18990 RVA: 0x0010DB1D File Offset: 0x0010BD1D
		public void SetLocalSignature(byte[] localSignature)
		{
			this.m_localSignature = ((localSignature != null) ? ((byte[])localSignature.Clone()) : EmptyArray<byte>.Value);
		}

		/// <summary>Sets the local variable signature that describes the layout of local variables for the associated dynamic method.</summary>
		/// <param name="localSignature">An array that contains the layout of local variables for the associated <see cref="T:System.Reflection.Emit.DynamicMethod" />.</param>
		/// <param name="signatureSize">The number of bytes in the signature.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="localSignature" /> is <see langword="null" /> and <paramref name="signatureSize" /> is greater than 0.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="signatureSize" /> is less than 0.</exception>
		// Token: 0x06004A2F RID: 18991 RVA: 0x0010DB3C File Offset: 0x0010BD3C
		[SecurityCritical]
		[CLSCompliant(false)]
		public unsafe void SetLocalSignature(byte* localSignature, int signatureSize)
		{
			if (signatureSize < 0)
			{
				throw new ArgumentOutOfRangeException("signatureSize", Environment.GetResourceString("ArgumentOutOfRange_GenericPositive"));
			}
			if (signatureSize > 0 && localSignature == null)
			{
				throw new ArgumentNullException("localSignature");
			}
			this.m_localSignature = new byte[signatureSize];
			for (int i = 0; i < signatureSize; i++)
			{
				this.m_localSignature[i] = *localSignature;
				localSignature++;
			}
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a method to be accessed from the associated dynamic method.</summary>
		/// <param name="method">The method to be accessed.</param>
		/// <returns>A token that can be used as the operand of an MSIL instruction that accesses methods, such as <see cref="F:System.Reflection.Emit.OpCodes.Call" /> or <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		// Token: 0x06004A30 RID: 18992 RVA: 0x0010DB9D File Offset: 0x0010BD9D
		[SecuritySafeCritical]
		public int GetTokenFor(RuntimeMethodHandle method)
		{
			return this.DynamicScope.GetTokenFor(method);
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a dynamic method to be called from the associated method.</summary>
		/// <param name="method">The dynamic method to call.</param>
		/// <returns>A token that can be embedded in the MSIL stream for the associated dynamic method, as the target of an MSIL instruction.</returns>
		// Token: 0x06004A31 RID: 18993 RVA: 0x0010DBAB File Offset: 0x0010BDAB
		public int GetTokenFor(DynamicMethod method)
		{
			return this.DynamicScope.GetTokenFor(method);
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a method on a generic type.</summary>
		/// <param name="method">The method.</param>
		/// <param name="contextType">The generic type the method belongs to.</param>
		/// <returns>A token that can be used as the operand of an MSIL instruction that accesses methods, such as <see cref="F:System.Reflection.Emit.OpCodes.Call" /> or <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" />, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		// Token: 0x06004A32 RID: 18994 RVA: 0x0010DBB9 File Offset: 0x0010BDB9
		public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType)
		{
			return this.DynamicScope.GetTokenFor(method, contextType);
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a field to be accessed from the associated dynamic method.</summary>
		/// <param name="field">The field to be accessed.</param>
		/// <returns>A token that can be used as the operand of an MSIL instruction that accesses fields, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		// Token: 0x06004A33 RID: 18995 RVA: 0x0010DBC8 File Offset: 0x0010BDC8
		public int GetTokenFor(RuntimeFieldHandle field)
		{
			return this.DynamicScope.GetTokenFor(field);
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a field to be accessed from the associated dynamic method; the field is on the specified generic type.</summary>
		/// <param name="field">The field to be accessed.</param>
		/// <param name="contextType">The generic type the field belongs to.</param>
		/// <returns>A token that can be used as the operand of an MSIL instruction that accesses fields in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		// Token: 0x06004A34 RID: 18996 RVA: 0x0010DBD6 File Offset: 0x0010BDD6
		public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType)
		{
			return this.DynamicScope.GetTokenFor(field, contextType);
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a type to be used in the associated dynamic method.</summary>
		/// <param name="type">The type to be used.</param>
		/// <returns>A token that can be used as the operand of an MSIL instruction that requires a type, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		// Token: 0x06004A35 RID: 18997 RVA: 0x0010DBE5 File Offset: 0x0010BDE5
		public int GetTokenFor(RuntimeTypeHandle type)
		{
			return this.DynamicScope.GetTokenFor(type);
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing a string literal to be used in the associated dynamic method.</summary>
		/// <param name="literal">The string to be used.</param>
		/// <returns>A token that can be used as the operand of an MSIL instruction that requires a string, in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" /> object.</returns>
		// Token: 0x06004A36 RID: 18998 RVA: 0x0010DBF3 File Offset: 0x0010BDF3
		public int GetTokenFor(string literal)
		{
			return this.DynamicScope.GetTokenFor(literal);
		}

		/// <summary>Gets a token, valid in the scope of the current <see cref="T:System.Reflection.Emit.DynamicILInfo" />, representing the signature for the associated dynamic method.</summary>
		/// <param name="signature">An array that contains the signature.</param>
		/// <returns>A token that can be embedded in the metadata and the MSIL stream for the associated dynamic method.</returns>
		// Token: 0x06004A37 RID: 18999 RVA: 0x0010DC01 File Offset: 0x0010BE01
		public int GetTokenFor(byte[] signature)
		{
			return this.DynamicScope.GetTokenFor(signature);
		}

		// Token: 0x04001E96 RID: 7830
		private DynamicMethod m_method;

		// Token: 0x04001E97 RID: 7831
		private DynamicScope m_scope;

		// Token: 0x04001E98 RID: 7832
		private byte[] m_exceptions;

		// Token: 0x04001E99 RID: 7833
		private byte[] m_code;

		// Token: 0x04001E9A RID: 7834
		private byte[] m_localSignature;

		// Token: 0x04001E9B RID: 7835
		private int m_maxStackSize;

		// Token: 0x04001E9C RID: 7836
		private int m_methodSignature;
	}
}
